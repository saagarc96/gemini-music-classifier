// Prisma Schema for Music Classification Review Interface
// This defines the database structure for storing songs and AI classifications

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("POSTGRES_URL_NON_POOLING") // Direct connection for local dev
  directUrl = env("POSTGRES_URL_NON_POOLING") // Uses direct connection for migrations
}

// User authentication and roles
model User {
  id           String   @id @default(cuid())
  email        String   @unique @db.VarChar(255)
  passwordHash String   @map("password_hash")
  name         String   @db.VarChar(255)
  role         Role     @default(CURATOR)
  active       Boolean  @default(true)
  createdAt    DateTime @default(now()) @map("created_at")
  lastLoginAt  DateTime? @map("last_login_at")

  // Relations
  reviewedSongs Song[] @relation("ReviewedBy")
  createdSongs  Song[] @relation("CreatedBy")
  approvedSongs Song[] @relation("ApprovedBy")

  @@map("users")
}

enum Role {
  ADMIN
  CURATOR
}

model Song {
  id       Int    @id @default(autoincrement())
  isrc     String @unique @db.VarChar(12)

  // Original CSV metadata
  title       String?
  artist      String?
  energy      String? @db.VarChar(20)
  bpm         Int?
  subgenre    String?
  artwork     String?
  sourceFile  String? @map("source_file")

  // Media URLs
  s3Url               String? @map("s3_url")
  artworkUrl          String? @map("artwork_url")

  // Spotify integration
  spotifyTrackId      String? @map("spotify_track_id") @db.VarChar(50)
  spotifyPreviewUrl   String? @map("spotify_preview_url")
  spotifyArtworkUrl   String? @map("spotify_artwork_url")

  // AI classifications (editable by curators)
  aiStatus        String? @map("ai_status") @db.VarChar(50)
  aiErrorMessage  String? @map("ai_error_message")
  aiReasoning     String? @map("ai_reasoning")
  aiContextUsed   String? @map("ai_context_used")
  aiEnergy        String? @map("ai_energy") @db.VarChar(20)
  aiAccessibility String? @map("ai_accessibility") @db.VarChar(20)
  aiExplicit      String? @map("ai_explicit") @db.VarChar(20)
  aiSubgenre1     String? @map("ai_subgenre_1") @db.VarChar(100)
  aiSubgenre2     String? @map("ai_subgenre_2") @db.VarChar(100)
  aiSubgenre3     String? @map("ai_subgenre_3") @db.VarChar(100)

  // Review metadata (for metadata edits)
  reviewed     Boolean   @default(false)
  reviewedBy   String?   @map("reviewed_by") @db.VarChar(100)
  reviewedById String?   @map("reviewed_by_id")
  reviewer     User?     @relation("ReviewedBy", fields: [reviewedById], references: [id], onDelete: SetNull)
  reviewedAt   DateTime? @map("reviewed_at")
  curatorNotes String?   @map("curator_notes")

  // Approval workflow (separate from metadata review)
  approvalStatus String    @default("PENDING") @map("approval_status") @db.VarChar(20)
  approvedBy     String?   @map("approved_by") @db.VarChar(100)
  approvedById   String?   @map("approved_by_id")
  approver       User?     @relation("ApprovedBy", fields: [approvedById], references: [id], onDelete: SetNull)
  approvedAt     DateTime? @map("approved_at")

  // Creator tracking
  createdById  String?   @map("created_by_id")
  creator      User?     @relation("CreatedBy", fields: [createdById], references: [id], onDelete: SetNull)

  // Duplicate tracking
  isDuplicate     Boolean  @default(false) @map("is_duplicate")
  originalIsrc    String?  @map("original_isrc") @db.VarChar(12)
  uploadBatchId   String?  @map("upload_batch_id") @db.VarChar(50)
  uploadBatchName String?  @map("upload_batch_name") @db.VarChar(255)

  // Playlist tracking (many-to-many via PlaylistSong)
  playlists PlaylistSong[]

  // Timestamps
  createdAt  DateTime @default(now()) @map("created_at")
  modifiedAt DateTime @default(now()) @updatedAt @map("modified_at")

  @@index([isrc])
  @@index([aiSubgenre1], map: "idx_subgenre_1")
  @@index([aiSubgenre2], map: "idx_subgenre_2")
  @@index([aiSubgenre3], map: "idx_subgenre_3")
  @@index([aiStatus], map: "idx_status")
  @@index([reviewed])
  @@index([approvalStatus], map: "idx_approval_status")
  @@index([approvedById], map: "idx_approved_by_id")
  @@index([spotifyTrackId], map: "idx_spotify_track_id")
  @@index([reviewedById], map: "idx_reviewed_by_id")
  @@index([createdById], map: "idx_created_by_id")
  @@index([isDuplicate], map: "idx_is_duplicate")
  @@index([originalIsrc], map: "idx_original_isrc")
  @@index([uploadBatchId], map: "idx_upload_batch_id")
  @@index([uploadBatchName], map: "idx_upload_batch_name")
  @@map("songs")
}

// Playlist tracking for uploaded CSV batches
model Playlist {
  id              String   @id @default(cuid())
  name            String   @db.VarChar(255)
  uploadBatchId   String   @map("upload_batch_id") @db.VarChar(50)
  uploadedByName  String?  @map("uploaded_by_name") @db.VarChar(255)
  uploadedAt      DateTime @default(now()) @map("uploaded_at")
  sourceFile      String?  @map("source_file") @db.VarChar(255)

  // Stats (updated after upload completes)
  totalSongs      Int      @default(0) @map("total_songs")
  newSongs        Int      @default(0) @map("new_songs")
  duplicateSongs  Int      @default(0) @map("duplicate_songs")

  // Relations
  songs           PlaylistSong[]

  @@index([uploadBatchId], map: "idx_playlist_batch_id")
  @@index([uploadedByName], map: "idx_playlist_uploader")
  @@index([uploadedAt], map: "idx_playlist_uploaded_at")
  @@map("playlists")
}

// Junction table for many-to-many relationship between Playlist and Song
model PlaylistSong {
  id         String   @id @default(cuid())
  playlistId String   @map("playlist_id")
  songIsrc   String   @map("song_isrc") @db.VarChar(12)
  addedAt    DateTime @default(now()) @map("added_at")
  wasNew     Boolean  @default(false) @map("was_new")

  // Relations
  playlist   Playlist @relation(fields: [playlistId], references: [id], onDelete: Cascade)
  song       Song     @relation(fields: [songIsrc], references: [isrc], onDelete: Cascade)

  @@unique([playlistId, songIsrc])
  @@index([playlistId], map: "idx_playlist_song_playlist")
  @@index([songIsrc], map: "idx_playlist_song_isrc")
  @@map("playlist_songs")
}
